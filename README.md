# MaxSAT
ここでいうMaxSATとは，ある和積型論理式について，変数を任意に動かした時に真となるクローズの個数の最大値を求める問題のこととする．  
式のサイズが大きくなった時に厳密に解を求めるのは計算時間的に困難なので，近似的に求められることが多い．  
ここではそのような方法のうち２つについて実装した．  
ここで対象とする論理式は例えば以下のようなものである．  
<img src="https://github.com/shutakahama/MaxSAT/blob/master/img/boolean_exp.png" width="500">  
この例では変数の数k=2，クローズの数m=4である．  

## 方法１
方法１では各変数x_iを確率1/2でランダムに0か1にする．各クローズの中に1つでも真があればクローズの値は真になるので，各クローズが偽になる確率α_k = 1 − (1/2)^k となる．  
よって真になるクローズの個数の期待値はm * α_kであり，これはk=1で最小m/2個となる．  

## 方法２
方法２では各変数を0か1のどちらかではなく0から1の連続値を取るというふうに条件を緩和し，各クローズを条件式として真になるクローズの個数を最大化する．その後各変数をその値に応じた確率で丸める(randomized rounding)することで改めて実際に真にできるクローズの個数を求める．  
この方法ではβ_k = 1 - (1 - 1/k)^kとして，丸める前と後のクローズの数が N_after >= β_k * N_before となることが示せる．  
ただし，α_kとβ_kは係数として意味するものが異なって比較ができないため，N_after >= γ_k * m を満たすようなγ_kも計算する．  

## 実行
実行時には変数の個数kとroopの回数rを指定できる．  
各関数を実行すると，k変数論理式をランダムにr個発生させ，それに対しα_k, β_k, γ_kの平均を出力する．  
MaxSAT.pyとMaxSAT.ipynbはほぼ同様の内容が実装されている．  

- 実行環境 (versionに強い指定はなし)
```
python=3.6
numpy=1.14
pulp=1.6
argparse = 1.1
```

- スクリプト例
```
python3 Max_SAT.py -r 10 -k 3
```
- 出力例
```
alpha:  0.9016666666666667
beta:  0.9383333333333332
gamma:  0.9383333333333332
```

## 結果
<img src="https://github.com/shutakahama/MaxSAT/blob/master/img/result.png" width="500">  
手法1では理論値と実験値が概ね一致しており， kが増加するにつれて真にできるクローズの数が1に近づく．  
手法2ではβ_kとγ_kは下限値を表しているため実験値は理論値よりも大きくなっている．  
なおN_beforeはkが大きいときはほとんどmに一致するため，α_kとβ_kは同じタイプの係数として比較可能であることがわかる．  
```
